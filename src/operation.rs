use sqlx::{PgPool, Postgres, Transaction};

/// Database operation wrapper providing transaction management and optional time tracking.
///
/// Encapsulates a PostgreSQL transaction with optional timestamp for event sourcing
/// and auditing. Used in the atomic/transactional database operation functions
/// generated by [crate::EsRepo]. Supports simulated time mode via the `sim-time` feature flag.
/// Has support for methods to convert to `Transaction` type (mutable references and owned)
///
/// # Features
///
/// The macro automatically includes different trait implementations based on enabled features:
/// - `sim-time`: Adds the current timestamp on `init` call
///
/// # Examples
/// ```rust
/// use sqlx::{PgPool, Postgres, Transaction};
/// use es_entity::DbOp;
///
/// async fn example(pool: &PgPool) -> Result<(), sqlx::Error> {
///     // Initialize from pool
///     let mut op = DbOp::init(pool).await?;
///     
///     // Use the transaction in a series of database transactions
///     // ...
///     // let result = users.create_in_op(&mut op, NewEntity).await?;
///     // Commit the transaction
///
///     op.commit().await?;
///     Ok(())
/// }
/// ```
/// ```rust
/// use sqlx::{PgPool, Postgres, Transaction};
/// use es_entity::DbOp;
///
/// async fn example(pool: &PgPool) -> Result<(), sqlx::Error> {
///     // Get transaction from pool
///     let tx = pool.begin().await?;
///     let time = chrono::Utc::now();
///     
///     // Create operation with explicit timestamp
///     let mut op = DbOp::new(tx, time);
///     
///     // Use the transaction in a series of database transactions
///     // ...
///     // let result = users.create_in_op(&mut op, NewEntity).await?;
///     // Commit the transaction
///
///     op.commit().await?;
///     Ok(())
/// }
/// ```

pub struct DbOp<'t> {
    tx: Transaction<'t, Postgres>,
    now: Option<chrono::DateTime<chrono::Utc>>,
}

impl<'t> DbOp<'t> {
    pub fn new(tx: Transaction<'t, Postgres>, time: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            tx,
            now: Some(time),
        }
    }

    pub async fn init(pool: &PgPool) -> Result<Self, sqlx::Error> {
        #[cfg(feature = "sim-time")]
        let res = {
            let tx = pool.begin().await?;
            let now = sim_time::now();
            Self { tx, now: Some(now) }
        };

        #[cfg(not(feature = "sim-time"))]
        let res = {
            let tx = pool.begin().await?;
            Self { tx, now: None }
        };

        Ok(res)
    }

    pub fn now(&self) -> Option<chrono::DateTime<chrono::Utc>> {
        self.now
    }

    /// Returns a mutable reference to the `Transaction<'t, Postgres>` value
    pub fn tx(&mut self) -> &mut Transaction<'t, Postgres> {
        &mut self.tx
    }

    /// Returns an owned `Transaction<'t, Postgres>` value by consuming the `DbOp`
    pub fn into_tx(self) -> Transaction<'t, Postgres> {
        self.tx
    }

    pub async fn commit(self) -> Result<(), sqlx::Error> {
        self.tx.commit().await?;
        Ok(())
    }
}
