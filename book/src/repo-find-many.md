# fn find_many

Combines the features of `list_by` and `list_for` into a flexible method that handles both filtered and 
unfiltered queries, sorted across different columns. Columns with `list_by` become sorting options and 
columns with `list_for` become filter options, with automatically generated `enums` and `cursor` structs.

```rust
# extern crate es_entity;
# extern crate sqlx;
# extern crate serde;
# extern crate tokio;
# extern crate anyhow;
# use serde::{Deserialize, Serialize};
# es_entity::entity_id! { UserId }
# #[derive(EsEvent, Debug, Serialize, Deserialize)]
# #[serde(tag = "type", rename_all = "snake_case")]
# #[es_event(id = "UserId")]
# pub enum UserEvent {
#     Initialized { id: UserId, name: String },
# }
# impl IntoEvents<UserEvent> for NewUser {
#     fn into_events(self) -> EntityEvents<UserEvent> {
#         EntityEvents::init(
#             self.id,
#             [UserEvent::Initialized {
#                 id: self.id,
#                 name: self.name,
#             }],
#         )
#     }
# }
# impl TryFromEvents<UserEvent> for User {
#     fn try_from_events(events: EntityEvents<UserEvent>) -> Result<Self, EsEntityError> {
#         Ok(User { id: events.id().clone(), name: "Fred".to_string(), events })
#     }
# }
# pub struct NewUser { id: UserId, name: String }
use es_entity::*;

#[derive(EsEntity)]
pub struct User {
    pub id: UserId,
    name: String,
    events: EntityEvents<UserEvent>,
}

#[derive(EsRepo)]
#[es_repo(entity = "User", columns(name(ty = "String", list_for)))]
pub struct Users {
    pool: sqlx::PgPool
}

# async fn init_pool() -> anyhow::Result<sqlx::PgPool> {
#     let pg_con = format!("postgres://user:password@localhost:5432/pg");
#     Ok(sqlx::PgPool::connect(&pg_con).await?)
# }
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let users = Users {
        pool: init_pool().await?,
    };

    let new_users = vec![
        NewUser {
            id: UserId::new(),
            name: "Murphy".to_string(),
        },
        NewUser {
            id: UserId::new(),
            name: "Murphy".to_string(),
        },
    ];
    users.create_all(new_users).await?;

    let result = users
        .find_many(
            // `FindManyUsers::WithName` generated by `EsRepo` using `list_for` option on `name`
            FindManyUsers::WithName("Murphy".to_string()),
            Sort {
                // `UsersSortBy::Id` and `UsersSortBy::CreatedAt` are created by default,
                // other columns need `list_by` to sort by
                by: UsersSortBy::Id,
                direction: ListDirection::Descending,
            },
            PaginatedQueryArgs {
                first: 10,
                after: Default::default(),
            },
        )
        .await?;
        
    // Returns 2 even when requested for 10 entities
    assert_eq!(result.entities.len(), 2);

    Ok(())
}
```
